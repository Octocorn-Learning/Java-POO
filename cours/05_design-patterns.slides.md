---
title: Design Patterns
theme: solarized
author: Alexandre Devos
company: Octocorn
contributors:
  - Alexandre Devos
sources:
  - https://refactoring.guru/
---

# Design patterns

![Logo Java](./assets/java.png) <!-- .element width="20%" align="left" -->

![IntelliJ](assets/intellij.png) <!-- .element width="30%" align="right" -->

----

## Design patterns

### D√©finition

- Patron de conception
- Un design pattern est une **solution** √† un **probl√®me r√©current**
- Elle est **√©prouv√©e** et **document√©e**

----

## Design patterns

### Origines

- 1977 : Christopher Alexander publie *A Pattern Language*
- Il contient des solutions √† des probl√®mes d'architecture urbaine
- L'id√©e est reprise par "The Gang of Four" en 1994

----

## Design patterns

### The Gang of Four

- Erich Gamma, Richard Helm, Ralph Johnson et John Vlissides
- Ils publient *Design Patterns: Elements of Reusable Object-Oriented Software* en 1994
- Ils y d√©crivent 23 design patterns class√©s en 3 cat√©gories

> Titre trop long, il est souvent abr√©g√© en *The GoF Book*

----

## Design patterns

### The GoF Boof

- Ils traitent 23 cas communs de d√©veloppement et proposent une solution pour chacun
- Concernent initialement le C++, mais peut √™tre appliqu√© √† tous les langages orient√©s objet
- Ils mettent un nom sur ces usages, et les classent en 3 cat√©gories :
    - Cr√©ation
    - Structure
    - Comportement

----

## Design patterns

### Cr√©ation

- Abstract Factory
- Builder
- Factory Method
- Prototype
- Singleton

> D√©signe la mani√®re de cr√©er des objets
----

## Design patterns

### Structure

- Adapter
- Bridge
- Composite
- Decorator
- Facade
- Flyweight
- Proxy

> D√©signe la mani√®re de structurer les classes et les objets

----

## Design patterns

### Comportement

- Chain of Responsibility
- Command
- Interpreter
- Iterator
- Mediator
- Memento

> D√©signe la mani√®re de g√©rer les interactions entre les objets

----

## Design patterns

### Comportement (suite)

- Observer
- State
- Strategy
- Template Method
- Visitor

> D√©signe la mani√®re de g√©rer les interactions entre les objets

----

## Design patterns

### Utilisation

- Il ne s'agit pas "d'importer une lib" ou "d'ajouter une d√©pendance"
- C'est une r√©flexion sur la mani√®re de r√©soudre un probl√®me
- Elles se veulent g√©n√©riques et r√©utilisables

----

## Design patterns

### Dans ce cours

- Nous n'aborderons pas tous les design patterns dans ce cours
- Nous nous concentrerons sur une dizaine de design patterns les plus courants

----

## Design patterns

### Sources

- [The GoF Book](https://bit.ly/amazon-gof)
- [Refactoring Guru](https://refactoring.guru/)

----

## Design patterns

### Obligatoires ?

- Connaitre les design patterns est un plus, pas une obligation
- Il est important de connaitre les probl√®mes qu'ils r√©solvent
- Sur le principe : on pourrait coder pendant des ann√©es sans les connaitre !

> Vous en avez d√©j√† utilis√© sans le savoir !

----

## Design patterns

### Communiquer

- Les design patterns sont communs √† tous les langages orient√©s objet
- Les connaitre permet de communiquer avec d'autres d√©veloppeurs

---

# Design patterns

## Singleton

![Logo Java](./assets/java.png) <!-- .element width="20%" align="left" -->

![IntelliJ](assets/intellij.png) <!-- .element width="30%" align="right" -->

----

## Singleton

### D√©finition

- Le singleton est un design pattern de type *cr√©ation*
- Il permet de s'assurer qu'une classe n'a qu'une seule instance !
- Elle fournit un acc√®s global √† cette instance

----

## Singleton

### Usages

- Lorsqu'on a besoin d'une classe qui ne doit exister qu'en un seul exemplaire
- Par exemple :
    - une classe qui g√®re les logs de l'application
    - Une classe pour la connection √† une base de donn√©es
    - Une classe pour g√©rer les controllers dans un framework

----

## Singleton

### Impl√©mentation

- Il existe plusieurs mani√®res d'impl√©menter un singleton
- Nous allons voir la plus simple : le singleton "paresseux"
- Il s'agit d'une classe qui se cr√©e elle-m√™me lorsqu'on l'appelle pour la premi√®re fois
- Elle se cr√©e donc au premier appel, et ne se recr√©e plus jamais

----

## Singleton

### Etapes

1. Cr√©ation d'un constructeur **priv√©**
2. Cr√©ation d'une variable **priv√©e** et **statique** de type de la classe, nomm√© `instance`
3. Cr√©ation d'un getter `getInstance()` qui retourne la variable `instance`
4. Dans le getter, si la variable `instance` est `null`, on la cr√©e, sinon on la retourne

----

## Singleton

### D√©monstration !

----

## Singleton

### Exemple

```java
public class Singleton {
    private static Singleton instance;

    private Singleton() {
    }

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

----

## Singleton

### Exemple

```java
public class Main {
    public static void main(String[] args) {
        Singleton singleton = Singleton.getInstance();
    }
}
```

----

## Singleton

### Inconv√©nients

- Le singleton "paresseux" n'est pas *thread-safe* !
- Ne r√©specte pas le SRP : il r√©sout le probl√®me d'unicit√©, mais aussi celui de la cr√©ation
- Difficile √† tester : il est impossible de mocker la classe (car le constructeur est priv√©)

Note: Si deux threads appellent `getInstance()` en m√™me temps, deux instances seront cr√©√©es (nb : une adaptation est
possible). Cf. partie facultative de la d√©mo.

----

## Singleton

### Bonne pratique ?

- Le singleton est un design pattern tr√®s controvers√©
- S'il a longtemps √©t√© consid√©r√© comme une bonne pratique, il est aujourd'hui **d√©conseill√©** üò±

> Pourquoi ?

----

## Singleton

### D√©pendance forte

- Le singleton cr√©e une **d√©pendance forte** entre les classes
- En cas de re-factorisation, c'est **tr√®s difficile** de s'en d√©barrasser !

> Les probl√®mes arrivent en g√©n√©ral plus tard !

----

## Singleton

### Des abus

- Le singleton est souvent utilis√© √† tort et √† travers
- Il arrive que ce soit pour camoufler un probl√®me de conception

---

# Design patterns

## Factory

![Logo Java](./assets/java.png) <!-- .element width="20%" align="left" -->

![IntelliJ](assets/intellij.png) <!-- .element width="30%" align="right" -->

----

## Factory

### D√©finition

- Le factory est un design pattern de type *cr√©ation*
- Il permet de cr√©er des objets sans avoir √† connaitre leur type √† l'avance
- L'√©volution du code est alors facilit√©e !

----

## Factory

### Cas concret

- Vous devez cr√©er une application de gestion de transport de marchandises
- L'entreprise utilise exclusivement des camions.
- La majorit√© de la logique m√©tier se trouve dans la classe `Truck`

----

## Factory

### Cas concret

- Puis, l'entreprise d√©cide d'acheter des bateaux pour transporter des marchandises par voie maritime
- Elle vous demande un "petit changement" : prendre en compte les bateaux dans l'application
- Vous avez d√©j√† un couplage tr√®s fort entre votre application et la classe `Truck`
- Le changement va √™tre difficile !

----

## Factory

### La logique

- Ici, on va d√©l√©guer la construction des objets √† une classe d√©di√©e : la factory
- On appellera plus directement `new Truck()`, mais `factory.createTransport()` par exemple
- Nous cr√©ons alors une interface `Transport` qui sera impl√©ment√©e par `Truck` et `Boat`

----

## Factory

### En image

![Factory](assets/factory-pattern.png)

----

## Factory

### Lexique

- **Product** : l'interface commune √† tous les produits
- **ConcreteProduct** : les produits concrets qui impl√©mentent l'interface
- **Creator** : la classe qui cr√©e les factories
- **ConcreteCreator** : la factory concr√®te qui cr√©e les produits concrets

----

## Factory

### En √©tapes

1. Cr√©ation d'une interface (Product) qui contient les m√©thodes communes √† tous les produits
2. Cr√©ation des classes concr√®tes (ConcreteProduct) qui impl√©mentent l'interface
3. Cr√©ation d'une classe abstraite (Creator) qui contient la m√©thode de cr√©ation de produits
4. Cr√©ation d'une classe concr√®te (ConcreteCreator) qui impl√©mente la m√©thode de cr√©ation

----

## Factory

### D√©monstration !

----

## Factory

### Nomenclature

- Dans les exemples, nous avons suffix√© les classes (`Factory` -> `TruckFactory`)
- En g√©n√©ral, les cr√©ators ont un nom repr√©sentatif **m√©tier**. Les ConcreteCreator reprennent ce nom en suffixe.
- Ex: `Transporter` -> `TruckTransporter`, `BoatTransporter`

----

## Factory

### A vous de joeur !

R√©aliser le TP 5 sur la Factory !


---

# Design patterns

## Builder

![Logo Java](./assets/java.png) <!-- .element width="20%" align="left" -->

![IntelliJ](assets/intellij.png) <!-- .element width="30%" align="right" -->

----

## Builder

### D√©finition

- Le builder est un design pattern de type *cr√©ation*
- Il permet de cr√©er des objets complexes √©tape par √©tape

----

## Builder

### Cas concret

- Vous devez cr√©er une application pour construire des maisons
- Au d√©but, c'est simple : 4 murs, un toit, une porte et des fen√™tres
- Puis, on ajoute des options : un garage, une piscine, un jardin, etc.

> Quelle serait la solution la plus simple ?

----

## Builder

### Cas concret

- On pourrait cr√©er une classe `House` avec pleins d'attributs nullables
- Puis pour chaque cas, on remplit les attributs concern√©s, ou on les met √† null

> Solution simple, mais pas tr√®s propre !

----

## Builder

### Exemple

```java
public class House {
    private int walls;
    private int roof;
    private int door;
    private int windows;
    private int garage;
    private int pool;
    private int garden;
    private int chimney;
    private int solarPanel;
    private int alarm;
    private int airConditioning;
    private int heating;
    private int homeAutomation;
    private int elevator;
    private int cellar;
    private int balcony;
    private int terrace;
    private int veranda;

    public House(int walls,
                 int roof,
                 int door,
                 int windows,
                 int garage,
                 int pool,
                 int garden,
                 int chimney,
                 int solarPanel,
                 int alarm,
                 int airConditioning,
                 int heating,
                 int homeAutomation,
                 int elevator,
                 int cellar,
                 int balcony,
                 int terrace,
                 int veranda
    ) {
        this.walls = walls ??null;
        this.roof = roof ??null;
        this.door = door ??null;
        this.windows = windows ??null;
        this.garage = garage ??null;
        this.pool = pool ??null;
        this.garden = garden ??null;
        this.chimney = chimney ??null;
        this.solarPanel = solarPanel ??null;
        this.alarm = alarm ??null;
        this.airConditioning = airConditioning ??null;
        this.heating = heating ??null;
        this.homeAutomation = homeAutomation ??null;
        this.elevator = elevator ??null;
        this.cellar = cellar ??null;
        this.balcony = balcony ??null;
        this.terrace = terrace ??null;
        this.veranda = veranda ??null;
    }

    public int getWalls() {
        return walls;
    }

    public int getRoof() {
        return roof;
    }

    public int getDoor() {
        return door;
    }

    public int getWindows() {
        return windows;
    }

    public int getGarage() {
        return garage;
    }

    public int getPool() {
        return pool;
    }

    public int getGarden() {
        return garden;
    }

    public int getChimney() {
        return chimney;
    }

    public int getSolarPanel() {
        return solarPanel;
    }

    public int getAlarm() {
        return alarm;
    }

    public int getAirConditioning() {
        return airConditioning;
    }

    public int getHeating() {
        return heating;
    }

    public int getHomeAutomation() {
        return homeAutomation;
    }

    public int getElevator() {
        return elevator;
    }

    public int getCellar() {
        return cellar;
    }

    public int getBalcony() {
        return balcony;
    }

    public int getTerrace() {
        return terrace;
    }

    public int getVeranda() {
        return veranda;
    }

    public void setWalls(int walls) {
        this.walls = walls;
    }

    public void setRoof(int roof) {
        this.roof = roof;
    }

    public void setDoor(int door) {
        this.door = door;
    }

    public void setWindows(int windows) {
        this.windows = windows;
    }

    public void setGarage(int garage) {
        this.garage = garage;
    }

    public void setPool(int pool) {
        this.pool = pool;
    }

    public void setGarden(int garden) {
        this.garden = garden;
    }

    public void setChimney(int chimney) {
        this.chimney = chimney;
    }

    public void setSolarPanel(int solarPanel) {
        this.solarPanel = solarPanel;
    }

    public void setAlarm(int alarm) {
        this.alarm = alarm;
    }

    public void setAirConditioning(int airConditioning) {
        this.airConditioning = airConditioning;
    }

    public void setHeating(int heating) {
        this.heating = heating;
    }

    public void setHomeAutomation(int homeAutomation) {
        this.homeAutomation = homeAutomation;
    }

    public void setElevator(int elevator) {
        this.elevator = elevator;
    }

    public void setCellar(int cellar) {
        this.cellar = cellar;
    }

    public void setBalcony(int balcony) {
        this.balcony = balcony;
    }

    public void setTerrace(int terrace) {
        this.terrace = terrace;
    }

    public void setVeranda(int veranda) {
        this.veranda = veranda;
    }

    // Et toutes les autres m√©thodes...
}
```

OSKOUR ALED

----

## Builder

### Trop de param√®tres, tue les param√®tres

- On se retrouverait avec des param√®tres souvent inutilis√©s
- A chaque nouveau besoin : on devrait modifier la classe `House`

> Pas tr√®s SOLID tout √ßa !

----

## Builder

### Cas concret

- On pourrait cr√©er une classe `House` avec tous les attributs
- Puisqu'on respecte SOLID, on va cr√©er des sous-classes pour chaque type de maison
    - `HouseWithGarage`, `HouseWithPool`, etc.
- Mais on va vite se retrouver avec des dizaines de sous-classes !

> La solution est plus simple, mais devient vite ing√©rable !

----

## Builder

### Solution : builder !

- On va cr√©er une interface `Builder` qui va nous permettre de construire une maison
- Le builder contiendra diff√©rentes m√©thodes pour ajouter des options √† la maison
- `buildDoor()`, `buildWindows()`, `buildGarage()`, etc.
- Et une m√©thode finale `build()` ou `getResult()` qui retourne la maison

----

## Builder

### Le Directeur

- Classe facultative, qui permet de d√©finir des routines de construction
- Elle poss√®de un attribut `builder` qui contient le builder
- Le Client peut appeler le directeur, ou directement le builder

----

## Builder

### En image

![Builder](assets/builder.png) <!-- .element width="40%" -->

----

## Builder

### Lexique

- **Director** : classe facultative qui d√©finit des routines de construction
- **Builder** : interface qui d√©finit les m√©thodes de construction
- **ConcreteBuilder** : classe qui impl√©mente l'interface et construit les produits
- **Product** : le produit final
- **Client** : classe qui utilise le builder. S'adresse au directeur ou au builder directement

----

## Builder

### En √©tapes

1. On cr√©√© notre classe `House` qui contient les attributs de la maison
2. On cr√©√© notre interface `Builder` qui contient les m√©thodes de construction
3. On cr√©√© notre classe `HouseBuilder` qui impl√©mente l'interface
4. On cr√©√© notre classe `HouseDirector` qui contient le builder et les m√©thodes de construction

----

## Builder

### D√©monstration !

Cr√©ons notre petite maison !

---

# Design patterns

## Adapter

![Logo Java](./assets/java.png) <!-- .element width="20%" align="left" -->

![IntelliJ](assets/intellij.png) <!-- .element width="30%" align="right" -->

----

## Adapter

### D√©finition

- L'adapter est un design pattern de type *structure*
- Il permet de faire communiquer deux classes qui n'ont pas la m√™me interface

----

## Adapter

### Cas concret

- Vous devez cr√©er une application qui alimente ses donn√©es depuis une API externe
- Vous n'avez donc aucun contr√¥le sur le format/la forme des donn√©es
- La structure du JSON re√ßue est tr√®s diff√©rente de celle de votre application

> Vous cr√©ez un adaptateur pour transformer les donn√©es re√ßues en donn√©es utilisables

----

## Adapter

### Exemple

Donn√©es re√ßues :

```json
{
  "id": 1,
  "name": "Alexandre Devos",
  "email": "a.devos@octocorn.fr",
  "street": "Rue de la Paix",
  "city": "Paris",
  "zipcode": "75000",
  "country": "France",
  "phone": "0123456789",
  "entreprise": "Octocorn"
}
```

----

## Adapter

### Exemple

Donn√©es attendues :

```json
{
  "id": 1,
  "nom": "Alexandre Devos",
  "mail": "a.devos@octocorn.fr",
  "entreprise": {
    "denomination": "Octocorn",
    "telephone": "0123456789",
    "adresse": {
      "rue": "Rue de la Paix",
      "ville": "Paris",
      "codePostal": "75000",
      "pays": "France"
    }
  }
}
```

----

## Adapter

### En image

![Adapter](assets/adapter.png)

----

## Adapter

### Lexique

- **Client** : la classe qui utilise l'adapter
- **Adaptee** : classe incompatible (legacy, api ...), √† adapter
- **Target** : l'interface que le **client** utilise. Ce en quoi il faut "convertir" l'**adaptee**
- **Adapter** : la classe qui adapte l'interface de l'adaptee √† l'interface du client

----

## Adapter

### Dans notre cas

![Exemple Adapter](assets/adapter-exemple.png)

> Repr√©sentation simplifi√©e (sans interface)

----

## Adapter

### En √©tapes

1. Cr√©ation du `Client` qui utilise l'adapter
2. Cr√©ation du `Target` qui d√©finit les m√©thodes utilis√©es par le client
3. Cr√©ation de l'`Adaptee` qui contient l'objet √† adapter
4. Cr√©ation de l'`Adapter` qui impl√©mente l'interface `Target` et agr√®ge l'objet `Adaptee`

> Il peut arriver que certaines √©tapes soient d√©j√† existantes

----

## Adapter

### Use Cases

- Pluguer une API externe √† une application existante
- Refactorisation/nouvelle app bas√© sur une BDD existante (legacy)
- D√©commissionner une API existante

----

## Adapter

### D√©monstration !

---

# Design patterns

## Decorator

![Logo Java](./assets/java.png) <!-- .element width="20%" align="left" -->

![IntelliJ](assets/intellij.png) <!-- .element width="30%" align="right" -->

----

> En cours de r√©daction